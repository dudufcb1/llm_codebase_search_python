"""FastMCP server for codebase search."""
import sys
from typing import Optional, Literal
from fastmcp import FastMCP, Context
from fastmcp.exceptions import ToolError

try:
    from .config import settings
    from .embedder import Embedder
    from .judge import Judge, SearchResult as JudgeSearchResult
    from .qdrant_store import QdrantStore
except ImportError:
    from config import settings
    from embedder import Embedder
    from judge import Judge, SearchResult as JudgeSearchResult
    from qdrant_store import QdrantStore, SearchResult


# Initialize FastMCP server
mcp = FastMCP(
    name="codebase-search",
    version="0.1.0"
)

# Initialize services
embedder = Embedder(
    provider=settings.embedder_provider,
    api_key=settings.embedder_api_key,
    model_id=settings.embedder_model_id,
    base_url=settings.embedder_base_url
)

judge = Judge(
    provider=settings.judge_provider,
    api_key=settings.judge_api_key,
    model_id=settings.judge_model_id,
    max_tokens=settings.judge_max_tokens,
    temperature=settings.judge_temperature,
    base_url=settings.judge_base_url,
    system_prompt=settings.judge_system_prompt
)

qdrant_store = QdrantStore(
    url=settings.qdrant_url,
    api_key=settings.qdrant_api_key
)


def _format_search_results(query: str, workspace_path: str, results: list[SearchResult]) -> str:
    """Format search results as text."""
    if not results:
        return f'No se encontraron coincidencias para "{query}" en el workspace "{workspace_path}".'
    
    formatted_parts = [f'Query: {query}', f'Workspace: {workspace_path}', '']
    
    for result in results:
        formatted_parts.append(f'Ruta: {result.file_path}')
        formatted_parts.append(f'Score: {result.score:.4f}')
        formatted_parts.append(f'L칤neas: {result.start_line}-{result.end_line}')
        formatted_parts.append('---')
        formatted_parts.append(result.code_chunk.strip())
        formatted_parts.append('')
    
    return '\n'.join(formatted_parts)


def _format_rerank_results(query: str, workspace_path: str, reranked: list, summary: Optional[str] = None) -> str:
    """Format reranked results as text."""
    if not reranked:
        return f'No se encontraron resultados relevantes para "{query}" en el workspace "{workspace_path}".'
    
    formatted_parts = [f'Query: {query}', f'Workspace: {workspace_path}', '']
    
    if summary:
        formatted_parts.append('=== RESUMEN ===')
        formatted_parts.append(summary)
        formatted_parts.append('')
        formatted_parts.append('=== RESULTADOS REORDENADOS ===')
        formatted_parts.append('')
    
    for result in reranked:
        formatted_parts.append(f'Ruta: {result.file_path}')
        formatted_parts.append(f'Relevancia: {result.relevancia:.4f}')
        formatted_parts.append(f'Score original: {result.score:.4f}')
        formatted_parts.append(f'L칤neas: {result.start_line}-{result.end_line}')
        if result.razon:
            formatted_parts.append(f'Raz칩n: {result.razon}')
        formatted_parts.append('---')
        formatted_parts.append(result.code_chunk.strip())
        formatted_parts.append('')
    
    return '\n'.join(formatted_parts)


# Build dynamic docstring based on mode
if settings.collection_source == "codebase-indexer":
    _SEARCH_DOC = """B칰squeda sem치ntica en c칩digo indexado.

丘뙖잺 MODO ACTUAL: CODEBASE-INDEXER

游늷 MODO CODEBASE-INDEXER - Lee .codebase/state.json

PAR츼METROS:
- query (requerido): Texto a buscar
- qdrantCollection (REQUERIDO): Nombre de colecci칩n desde workspace/.codebase/state.json
- path (opcional): Prefijo de ruta para filtrar resultados

INSTRUCCIONES MODO CODEBASE-INDEXER:
1. Ubicar archivo: <workspace>/.codebase/state.json
2. Leer campo "qdrantCollection" del JSON
3. Pasar ese valor como par치metro qdrantCollection
4. NO uses workspacePath, ser치 ignorado

Ejemplo:
{"query": "auth", "qdrantCollection": "codebase-f93e99958acc444e"}
"""
else:
    _SEARCH_DOC = """B칰squeda sem치ntica en c칩digo indexado.

丘뙖잺 MODO ACTUAL: DEFAULT

游늷 MODO DEFAULT - Usa workspace path

PAR츼METROS:
- query (requerido): Texto a buscar
- workspacePath (REQUERIDO): Ruta absoluta del workspace
- path (opcional): Prefijo de ruta para filtrar resultados

INSTRUCCIONES MODO DEFAULT:
1. Proporcionar ruta absoluta del workspace
2. El servidor calcular치 autom치ticamente la colecci칩n (hash SHA256)
3. NO uses qdrantCollection, ser치 ignorado

Ejemplo:
{"query": "auth", "workspacePath": "/home/user/project"}
"""


# Register tools conditionally based on settings
if settings.enable_search:
    @mcp.tool
    async def superior_codebase_search(
        query: str,
        workspace_path: Optional[str] = None,
        path: Optional[str] = None,
        qdrant_collection: Optional[str] = None,
        ctx: Context = None
    ) -> str:
        try:
            # Log request
            if ctx:
                await ctx.info(f"[Search] Mode: {settings.collection_source}, Query: {query}")
        else:
            print(f"[Search] Mode: {settings.collection_source}, Query: {query}", file=sys.stderr)

        # Validate inputs based on collection source mode
        if not query or not query.strip():
            raise ToolError("El par치metro 'query' es requerido y no puede estar vac칤o.")

        # Mode-specific validation
        if settings.collection_source == "codebase-indexer":
            # MODE: codebase-indexer - requires explicit collection name
            if not qdrant_collection:
                raise ToolError(
                    "MODO: codebase-indexer\n\n"
                    "Debes proporcionar 'qdrantCollection' en este modo.\n\n"
                    "El agente debe leer el archivo .codebase/state.json del workspace:\n"
                    "1. Localizar: <workspace>/.codebase/state.json\n"
                    "2. Leer el campo: qdrantCollection\n"
                    "3. Pasar ese valor en el par치metro qdrantCollection\n\n"
                    'Ejemplo: {"query": "auth", "qdrantCollection": "codebase-f93e99958acc444e"}'
                )
            effective_workspace = qdrant_collection  # Use collection as identifier for logging
            collection_to_use = qdrant_collection
        else:
            # MODE: default - requires workspace_path
            effective_workspace = workspace_path or settings.default_workspace_path
            if not effective_workspace:
                raise ToolError(
                    "MODO: default\n\n"
                    "Debes especificar 'workspacePath' o configurar MCP_CODEBASE_WORKSPACE.\n\n"
                    'Ejemplo: {"query": "auth", "workspacePath": "/path/to/project"}'
                )
            collection_to_use = None  # Will be calculated from workspace_path
        
        # Create embedding
        vector = await embedder.create_embedding(query)

        # Search in Qdrant
        results = await qdrant_store.search(
            vector=vector,
            workspace_path=effective_workspace,
            directory_prefix=path,
            min_score=settings.search_min_score,
            max_results=settings.search_max_results,
            collection_name=collection_to_use
        )
        
        # Format and return results
        return _format_search_results(query, effective_workspace, results)
        
    except ToolError:
        raise
    except Exception as e:
        error_msg = str(e)
        if ctx:
            await ctx.error(f"[Search] Error: {error_msg}")
        else:
            print(f"[Search] Error: {error_msg}", file=sys.stderr)
        raise ToolError(f"Error al buscar en el codebase: {error_msg}")


@mcp.tool
async def superior_codebase_rerank(
    query: str,
    workspace_path: Optional[str] = None,
    path: Optional[str] = None,
    mode: Literal["rerank", "summary"] = "rerank",
    qdrant_collection: Optional[str] = None,
    ctx: Context = None
) -> str:
    """Realiza una b칰squeda sem치ntica y reordena los resultados usando un LLM Judge.

    Esta herramienta primero ejecuta una b칰squeda sem치ntica y luego usa un modelo de lenguaje
    para evaluar y reordenar los resultados seg칰n su relevancia real a la consulta.

    MODO DE OPERACI칍N:
    Este servidor puede operar en dos modos seg칰n la variable de entorno MCP_CODEBASE_COLLECTION_SOURCE:

    1. MODO "default" (por defecto):
       - Requiere: workspacePath (ruta absoluta del workspace)
       - Calcula autom치ticamente el nombre de colecci칩n usando hash SHA256
       - Ejemplo: {"query": "auth logic", "workspacePath": "/home/user/my-project", "mode": "summary"}

    2. MODO "codebase-indexer":
       - Requiere: qdrantCollection (nombre de colecci칩n expl칤cito)
       - Compatible con code-index-cli que mantiene el 칤ndice actualizado
       - El agente debe leer el archivo .codebase/state.json del workspace para obtener qdrantCollection
       - Ejemplo: {"query": "auth logic", "qdrantCollection": "codebase-f93e99958acc444e", "mode": "summary"}
       - Para obtener qdrantCollection: leer workspace/.codebase/state.json["qdrantCollection"]

    Args:
        query: Texto natural a buscar en el c칩digo
        workspace_path: [MODO default] Ruta absoluta del workspace a buscar
        path: Prefijo de ruta opcional para filtrar resultados
        mode: Modo de operaci칩n - "rerank" solo reordena, "summary" incluye resumen
        qdrant_collection: [MODO codebase-indexer] Nombre de colecci칩n Qdrant desde .codebase/state.json
        ctx: FastMCP context for logging

    Returns:
        Resultados reordenados formateados como texto, opcionalmente con resumen
    """
    try:
        # Log request
        if ctx:
            await ctx.info(f"[Rerank] Mode: {settings.collection_source}, Query: {query}, Mode: {mode}")
        else:
            print(f"[Rerank] Mode: {settings.collection_source}, Query: {query}, Mode: {mode}", file=sys.stderr)

        # Validate inputs based on collection source mode
        if not query or not query.strip():
            raise ToolError("El par치metro 'query' es requerido y no puede estar vac칤o.")

        # Mode-specific validation
        if settings.collection_source == "codebase-indexer":
            # MODE: codebase-indexer - requires explicit collection name
            if not qdrant_collection:
                raise ToolError(
                    "MODO: codebase-indexer\n\n"
                    "Debes proporcionar 'qdrantCollection' en este modo.\n\n"
                    "El agente debe leer el archivo .codebase/state.json del workspace:\n"
                    "1. Localizar: <workspace>/.codebase/state.json\n"
                    "2. Leer el campo: qdrantCollection\n"
                    "3. Pasar ese valor en el par치metro qdrantCollection\n\n"
                    'Ejemplo: {"query": "auth", "qdrantCollection": "codebase-f93e99958acc444e", "mode": "summary"}'
                )
            effective_workspace = qdrant_collection  # Use collection as identifier for logging
            collection_to_use = qdrant_collection
        else:
            # MODE: default - requires workspace_path
            effective_workspace = workspace_path or settings.default_workspace_path
            if not effective_workspace:
                raise ToolError(
                    "MODO: default\n\n"
                    "Debes especificar 'workspacePath' o configurar MCP_CODEBASE_WORKSPACE.\n\n"
                    'Ejemplo: {"query": "auth", "workspacePath": "/path/to/project", "mode": "summary"}'
                )
            collection_to_use = None  # Will be calculated from workspace_path
        
        # Step 1: Perform initial search
        if ctx:
            await ctx.info(f"[Rerank] Buscando resultados para query: '{query}'")

        vector = await embedder.create_embedding(query)
        search_results = await qdrant_store.search(
            vector=vector,
            workspace_path=effective_workspace,
            directory_prefix=path,
            min_score=settings.search_min_score,
            max_results=settings.search_max_results,
            collection_name=collection_to_use
        )
        
        if not search_results:
            return f'No se encontraron resultados para "{query}" en el workspace "{effective_workspace}".'
        
        # Step 2: Convert to Judge format
        judge_results = [
            JudgeSearchResult(
                file_path=r.file_path,
                code_chunk=r.code_chunk,
                start_line=r.start_line,
                end_line=r.end_line,
                score=r.score
            )
            for r in search_results
        ]
        
        # Step 3: Rerank with LLM
        if ctx:
            await ctx.info(f"[Rerank] Reordenando {len(judge_results)} resultados con LLM")
        
        reranked = await judge.rerank(query, judge_results)
        
        # Apply max results limit
        reranked = reranked[:settings.reranking_max_results]
        
        # Step 4: Generate summary if requested
        summary = None
        if mode == "summary":
            if ctx:
                await ctx.info("[Rerank] Generando resumen")
            summary = await judge.summarize(query, judge_results)
        
        # Format and return results
        return _format_rerank_results(query, effective_workspace, reranked, summary)
        
    except ToolError:
        raise
    except Exception as e:
        error_msg = str(e)
        if ctx:
            await ctx.error(f"[Rerank] Error: {error_msg}")
        else:
            print(f"[Rerank] Error: {error_msg}", file=sys.stderr)
        raise ToolError(f"Error al reordenar resultados: {error_msg}")


# Entry point for fastmcp CLI
if __name__ == "__main__":
    print("[MCP] Servidor `codebase-search` inicializado y listo.", file=sys.stderr)
    mcp.run()

